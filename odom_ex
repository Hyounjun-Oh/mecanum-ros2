import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist, Point, Quaternion
from nav_msgs.msg import Odometry
import tf2_ros
from tf2_ros import TransformBroadcaster
from math import sin, cos, pi

class MecanumOdom(Node):

    def __init__(self):
        super().__init__('mecanum_odom_node')
        self.publisher_ = self.create_publisher(Odometry, 'odom', 10)
        self.subscription_ = self.create_subscription(
            Twist,
            'cmd_vel',
            self.cmd_vel_callback,
            10)
        self.subscription_
        self.broadcaster = TransformBroadcaster(self)

        self.x = 0.0
        self.y = 0.0
        self.th = 0.0
        self.vx = 0.0
        self.vy = 0.0
        self.vth = 0.0

        self.last_time = self.get_clock().now()

    def cmd_vel_callback(self, msg):
        vx = msg.linear.x
        vy = msg.linear.y
        vth = msg.angular.z

        # Define robot kinematics for mecanum wheels
        a = vx - vy - (self.th * pi / 4.0)
        b = vx + vy + (self.th * pi / 4.0)
        c = vx + vy - (self.th * pi / 4.0)
        d = vx - vy + (self.th * pi / 4.0)

        # Calculate linear and angular velocities
        self.vx = (a + b + c + d) / 4.0
        self.vy = (-a + b + c - d) / 4.0
        self.vth = (-a + b - c + d) / (4.0 * (0.25 * pi))

        current_time = self.get_clock().now()
        dt = (current_time - self.last_time).to_sec()
        self.last_time = current_time

        # Integrate velocities to determine robot pose
        self.x += (self.vx * cos(self.th) - self.vy * sin(self.th)) * dt
        self.y += (self.vx * sin(self.th) + self.vy * cos(self.th)) * dt
        self.th += self.vth * dt

        # Publish odometry message
